# API Documentation - Sistema de Controle Financeiro

## üìã Vis√£o Geral

Esta documenta√ß√£o detalha todos os servi√ßos, tipos TypeScript, hooks e fun√ß√µes utilizadas no sistema de controle financeiro pessoal.

**Base URL Supabase:** `https://nzgifjdewdfibcopolof.supabase.co`  
**Prefixo das Tabelas:** `fp_` (finan√ßas pessoais)

---

## üóÉÔ∏è Tipos TypeScript

### `/tipos/transacao.ts`

```typescript
export interface Transacao {
  id: string;
  data: string; // ISO date string
  descricao: string;
  valor: number; // Em reais (R$ 123.45)
  tipo: 'receita' | 'despesa' | 'transferencia';
  
  // Relacionamentos (opcionais)
  categoria_id?: string;
  subcategoria_id?: string;
  forma_pagamento_id?: string;
  centro_custo_id?: string;
  
  // Contas
  conta_id: string;
  conta_destino_id?: string; // Apenas para transfer√™ncias
  
  // Parcelamento
  parcela_atual: number;
  total_parcelas: number;
  grupo_parcelamento?: number; // BIGINT para suportar Date.now()
  
  // Recorr√™ncia
  recorrente: boolean;
  frequencia_recorrencia?: 'diario' | 'semanal' | 'mensal' | 'anual';
  proxima_recorrencia?: string; // ISO date string
  
  // Status e datas
  status: 'pendente' | 'pago' | 'cancelado';
  data_vencimento?: string;
  data_registro: string;
  
  // Extras
  anexo_url?: string;
  observacoes?: string;
  
  // Metadados
  created_at: string;
  updated_at: string;
}

export interface NovaTransacao extends Omit<
  Transacao, 
  'id' | 'created_at' | 'updated_at' | 'data_registro'
> {}

export interface AtualizarTransacao extends Partial<NovaTransacao> {}

export interface TransacaoComRelacoes extends Transacao {
  categoria?: {
    nome: string;
    cor: string;
    icone: string;
  };
  subcategoria?: {
    nome: string;
  };
  conta?: {
    nome: string;
    tipo: string;
  };
  conta_destino?: {
    nome: string;
    tipo: string;
  };
  forma_pagamento?: {
    nome: string;
    tipo: string;
  };
  centro_custo?: {
    nome: string;
    cor: string;
  };
}
```

### `/tipos/categoria.ts`

```typescript
export interface Categoria {
  id: string;
  nome: string;
  tipo: 'receita' | 'despesa' | 'ambos';
  icone: string;
  cor: string;
  ativo: boolean;
  created_at: string;
}

export interface NovaCategoria extends Omit<Categoria, 'id' | 'created_at'> {}

export interface CategoriaComSubcategorias extends Categoria {
  subcategorias: Subcategoria[];
}
```

### `/tipos/subcategoria.ts`

```typescript
export interface Subcategoria {
  id: string;
  nome: string;
  categoria_id: string;
  ativo: boolean;
  created_at: string;
}

export interface NovaSubcategoria extends Omit<Subcategoria, 'id' | 'created_at'> {}
```

### `/tipos/conta.ts`

```typescript
export interface Conta {
  id: string;
  nome: string;
  tipo: 'conta_corrente' | 'poupanca' | 'cartao_credito' | 'dinheiro';
  banco?: string;
  ativo: boolean;
  created_at: string;
}

export interface NovaConta extends Omit<Conta, 'id' | 'created_at'> {}

export interface ContaComSaldo extends Conta {
  saldo: number;
  saldo_formatado: string;
}
```

### `/tipos/meta.ts`

```typescript
export interface Meta {
  id: string;
  nome: string;
  descricao?: string;
  categoria_id?: string;
  valor_limite: number;
  periodo_inicio: string;
  periodo_fim: string;
  tipo: 'categoria' | 'total';
  ativo: boolean;
  created_at: string;
  updated_at: string;
}

export interface NovaMeta extends Omit<Meta, 'id' | 'created_at' | 'updated_at'> {}

export interface MetaComProgresso extends Meta {
  valor_usado: number;
  percentual_usado: number;
  valor_restante: number;
  status_cor: 'verde' | 'amarelo' | 'laranja' | 'vermelho';
  categoria?: {
    nome: string;
    cor: string;
  };
}
```

### `/tipos/forma-pagamento.ts`

```typescript
export interface FormaPagamento {
  id: string;
  nome: string;
  tipo: 'vista' | 'credito' | 'debito';
  permite_parcelamento: boolean;
  ativo: boolean;
  created_at: string;
}

export interface NovaFormaPagamento extends Omit<FormaPagamento, 'id' | 'created_at'> {}
```

### `/tipos/centro-custo.ts`

```typescript
export interface CentroCusto {
  id: string;
  nome: string;
  descricao?: string;
  cor: string;
  ativo: boolean;
  created_at: string;
}

export interface NovoCentroCusto extends Omit<CentroCusto, 'id' | 'created_at'> {}
```

### `/tipos/filtros.ts`

```typescript
export interface FiltrosTransacao {
  data_inicio?: string;
  data_fim?: string;
  categoria_id?: string;
  subcategoria_id?: string;
  conta_id?: string;
  tipo?: Transacao['tipo'];
  status?: Transacao['status'];
  valor_min?: number;
  valor_max?: number;
  recorrente?: boolean;
  busca?: string; // Busca na descri√ß√£o
}

export interface ParametrosPaginacao {
  pagina: number;
  limite: number;
  ordenacao?: 'data' | 'valor' | 'descricao';
  direcao?: 'asc' | 'desc';
}

export interface RespostaPaginada<T> {
  dados: T[];
  total: number;
  pagina: number;
  limite: number;
  total_paginas: number;
}
```

---

## üîå Servi√ßos Supabase

### `/servicos/supabase/transacoes.ts`

```typescript
import { supabase } from './cliente';
import type { 
  Transacao, 
  NovaTransacao, 
  AtualizarTransacao,
  TransacaoComRelacoes,
  FiltrosTransacao,
  ParametrosPaginacao,
  RespostaPaginada
} from '@/tipos';

/**
 * Buscar todas as transa√ß√µes com filtros e pagina√ß√£o
 */
export async function obterTransacoes(
  filtros: FiltrosTransacao = {},
  paginacao: ParametrosPaginacao = { pagina: 1, limite: 50 }
): Promise<RespostaPaginada<TransacaoComRelacoes>> {
  let query = supabase
    .from('fp_transacoes')
    .select(`
      *,
      categoria:fp_categorias(nome, cor, icone),
      subcategoria:fp_subcategorias(nome),
      conta:fp_contas(nome, tipo),
      conta_destino:fp_contas!conta_destino_id(nome, tipo),
      forma_pagamento:fp_formas_pagamento(nome, tipo),
      centro_custo:fp_centros_custo(nome, cor)
    `, { count: 'exact' });

  // Aplicar filtros
  if (filtros.data_inicio) {
    query = query.gte('data', filtros.data_inicio);
  }
  if (filtros.data_fim) {
    query = query.lte('data', filtros.data_fim);
  }
  if (filtros.categoria_id) {
    query = query.eq('categoria_id', filtros.categoria_id);
  }
  if (filtros.conta_id) {
    query = query.eq('conta_id', filtros.conta_id);
  }
  if (filtros.tipo) {
    query = query.eq('tipo', filtros.tipo);
  }
  if (filtros.status) {
    query = query.eq('status', filtros.status);
  }
  if (filtros.busca) {
    query = query.ilike('descricao', `%${filtros.busca}%`);
  }

  // Aplicar pagina√ß√£o e ordena√ß√£o
  const inicio = (paginacao.pagina - 1) * paginacao.limite;
  query = query
    .order(paginacao.ordenacao || 'data', { 
      ascending: paginacao.direcao === 'asc' 
    })
    .range(inicio, inicio + paginacao.limite - 1);

  const { data, error, count } = await query;

  if (error) throw new Error(`Erro ao buscar transa√ß√µes: ${error.message}`);

  return {
    dados: data || [],
    total: count || 0,
    pagina: paginacao.pagina,
    limite: paginacao.limite,
    total_paginas: Math.ceil((count || 0) / paginacao.limite)
  };
}

/**
 * Buscar transa√ß√£o por ID
 */
export async function obterTransacaoPorId(id: string): Promise<TransacaoComRelacoes | null> {
  const { data, error } = await supabase
    .from('fp_transacoes')
    .select(`
      *,
      categoria:fp_categorias(nome, cor, icone),
      subcategoria:fp_subcategorias(nome),
      conta:fp_contas(nome, tipo),
      conta_destino:fp_contas!conta_destino_id(nome, tipo),
      forma_pagamento:fp_formas_pagamento(nome, tipo),
      centro_custo:fp_centros_custo(nome, cor)
    `)
    .eq('id', id)
    .single();

  if (error && error.code !== 'PGRST116') {
    throw new Error(`Erro ao buscar transa√ß√£o: ${error.message}`);
  }

  return data;
}

/**
 * Criar nova transa√ß√£o
 */
export async function criarTransacao(transacao: NovaTransacao): Promise<Transacao> {
  const { data, error } = await supabase
    .from('fp_transacoes')
    .insert([transacao])
    .select()
    .single();

  if (error) throw new Error(`Erro ao criar transa√ß√£o: ${error.message}`);
  return data;
}

/**
 * Criar transa√ß√£o parcelada (m√∫ltiplas transa√ß√µes)
 */
export async function criarTransacaoParcelada(
  transacaoBase: NovaTransacao,
  numeroParcelas: number
): Promise<Transacao[]> {
  const grupoParcelamento = Date.now(); // ID √∫nico para agrupar (BIGINT)
  const valorParcela = Number((transacaoBase.valor / numeroParcelas).toFixed(2));
  
  const parcelas: NovaTransacao[] = [];
  const dataBase = new Date(transacaoBase.data);
  
  for (let i = 1; i <= numeroParcelas; i++) {
    const dataParcela = new Date(dataBase);
    dataParcela.setMonth(dataParcela.getMonth() + (i - 1));
    
    parcelas.push({
      ...transacaoBase,
      valor: valorParcela,
      parcela_atual: i,
      total_parcelas: numeroParcelas,
      grupo_parcelamento: grupoParcelamento,
      data: dataParcela.toISOString().split('T')[0],
      descricao: `${transacaoBase.descricao} (${i}/${numeroParcelas})`
    });
  }

  const { data, error } = await supabase
    .from('fp_transacoes')
    .insert(parcelas)
    .select();

  if (error) throw new Error(`Erro ao criar transa√ß√£o parcelada: ${error.message}`);
  return data;
}

/**
 * Atualizar transa√ß√£o
 */
export async function atualizarTransacao(
  id: string, 
  atualizacoes: AtualizarTransacao
): Promise<void> {
  const { error } = await supabase
    .from('fp_transacoes')
    .update(atualizacoes)
    .eq('id', id);

  if (error) throw new Error(`Erro ao atualizar transa√ß√£o: ${error.message}`);
}

/**
 * Excluir transa√ß√£o
 */
export async function excluirTransacao(id: string): Promise<void> {
  const { error } = await supabase
    .from('fp_transacoes')
    .delete()
    .eq('id', id);

  if (error) throw new Error(`Erro ao excluir transa√ß√£o: ${error.message}`);
}

/**
 * Excluir todas as parcelas de um grupo
 */
export async function excluirGrupoParcelamento(grupoParcelamento: number): Promise<void> {
  const { error } = await supabase
    .from('fp_transacoes')
    .delete()
    .eq('grupo_parcelamento', grupoParcelamento);

  if (error) throw new Error(`Erro ao excluir parcelas: ${error.message}`);
}

/**
 * Buscar transa√ß√µes recorrentes que precisam ser processadas
 */
export async function obterTransacoesRecorrentesVencidas(): Promise<Transacao[]> {
  const hoje = new Date().toISOString().split('T')[0];
  
  const { data, error } = await supabase
    .from('fp_transacoes')
    .select('*')
    .eq('recorrente', true)
    .lte('proxima_recorrencia', hoje);

  if (error) throw new Error(`Erro ao buscar recorr√™ncias: ${error.message}`);
  return data || [];
}
```

### `/servicos/supabase/categorias.ts`

```typescript
import { supabase } from './cliente';
import type { 
  Categoria, 
  NovaCategoria, 
  CategoriaComSubcategorias 
} from '@/tipos';

/**
 * Buscar todas as categorias ativas
 */
export async function obterCategorias(incluirInativas = false): Promise<Categoria[]> {
  let query = supabase
    .from('fp_categorias')
    .select('*')
    .order('nome');

  if (!incluirInativas) {
    query = query.eq('ativo', true);
  }

  const { data, error } = await query;

  if (error) throw new Error(`Erro ao buscar categorias: ${error.message}`);
  return data || [];
}

/**
 * Buscar categorias com subcategorias
 */
export async function obterCategoriasComSubcategorias(): Promise<CategoriaComSubcategorias[]> {
  const { data, error } = await supabase
    .from('fp_categorias')
    .select(`
      *,
      subcategorias:fp_subcategorias(*)
    `)
    .eq('ativo', true)
    .order('nome');

  if (error) throw new Error(`Erro ao buscar categorias: ${error.message}`);
  return data || [];
}

/**
 * Criar nova categoria
 */
export async function criarCategoria(categoria: NovaCategoria): Promise<Categoria> {
  const { data, error } = await supabase
    .from('fp_categorias')
    .insert([categoria])
    .select()
    .single();

  if (error) throw new Error(`Erro ao criar categoria: ${error.message}`);
  return data;
}

/**
 * Atualizar categoria
 */
export async function atualizarCategoria(
  id: string, 
  atualizacoes: Partial<NovaCategoria>
): Promise<void> {
  const { error } = await supabase
    .from('fp_categorias')
    .update(atualizacoes)
    .eq('id', id);

  if (error) throw new Error(`Erro ao atualizar categoria: ${error.message}`);
}

/**
 * Desativar categoria (soft delete)
 */
export async function desativarCategoria(id: string): Promise<void> {
  const { error } = await supabase
    .from('fp_categorias')
    .update({ ativo: false })
    .eq('id', id);

  if (error) throw new Error(`Erro ao desativar categoria: ${error.message}`);
}
```

### `/servicos/supabase/contas.ts`

```typescript
import { supabase } from './cliente';
import { formatarMoeda } from '@/utilitarios/formatacao';
import type { Conta, NovaConta, ContaComSaldo } from '@/tipos';

/**
 * Buscar todas as contas ativas
 */
export async function obterContas(incluirInativas = false): Promise<Conta[]> {
  let query = supabase
    .from('fp_contas')
    .select('*')
    .order('nome');

  if (!incluirInativas) {
    query = query.eq('ativo', true);
  }

  const { data, error } = await query;

  if (error) throw new Error(`Erro ao buscar contas: ${error.message}`);
  return data || [];
}

/**
 * Buscar contas com saldo calculado
 */
export async function obterContasComSaldo(): Promise<ContaComSaldo[]> {
  const contas = await obterContas();
  const contasComSaldo: ContaComSaldo[] = [];

  for (const conta of contas) {
    const saldo = await calcularSaldoConta(conta.id);
    contasComSaldo.push({
      ...conta,
      saldo,
      saldo_formatado: formatarMoeda(saldo)
    });
  }

  return contasComSaldo;
}

/**
 * Calcular saldo de uma conta espec√≠fica
 */
async function calcularSaldoConta(contaId: string): Promise<number> {
  // Receitas e despesas normais
  const { data: transacoes, error } = await supabase
    .from('fp_transacoes')
    .select('valor, tipo')
    .eq('conta_id', contaId)
    .eq('status', 'pago');

  if (error) throw new Error(`Erro ao calcular saldo: ${error.message}`);

  let saldo = 0;
  
  for (const transacao of transacoes || []) {
    if (transacao.tipo === 'receita') {
      saldo += transacao.valor;
    } else if (transacao.tipo === 'despesa') {
      saldo -= transacao.valor;
    }
    // Transfer√™ncias j√° s√£o tratadas separadamente
  }

  // Transfer√™ncias recebidas (como conta destino)
  const { data: transferenciasRecebidas, error: errorRecebidas } = await supabase
    .from('fp_transacoes')
    .select('valor')
    .eq('conta_destino_id', contaId)
    .eq('tipo', 'transferencia')
    .eq('status', 'pago');

  if (errorRecebidas) throw new Error(`Erro ao calcular transfer√™ncias: ${errorRecebidas.message}`);

  for (const transferencia of transferenciasRecebidas || []) {
    saldo += transferencia.valor;
  }

  // Transfer√™ncias enviadas (como conta origem)
  const { data: transferenciasEnviadas, error: errorEnviadas } = await supabase
    .from('fp_transacoes')
    .select('valor')
    .eq('conta_id', contaId)
    .eq('tipo', 'transferencia')
    .eq('status', 'pago');

  if (errorEnviadas) throw new Error(`Erro ao calcular transfer√™ncias: ${errorEnviadas.message}`);

  for (const transferencia of transferenciasEnviadas || []) {
    saldo -= transferencia.valor;
  }

  return saldo;
}

/**
 * Criar nova conta
 */
export async function criarConta(conta: NovaConta): Promise<Conta> {
  const { data, error } = await supabase
    .from('fp_contas')
    .insert([conta])
    .select()
    .single();

  if (error) throw new Error(`Erro ao criar conta: ${error.message}`);
  return data;
}

/**
 * Atualizar conta
 */
export async function atualizarConta(
  id: string, 
  atualizacoes: Partial<NovaConta>
): Promise<void> {
  const { error } = await supabase
    .from('fp_contas')
    .update(atualizacoes)
    .eq('id', id);

  if (error) throw new Error(`Erro ao atualizar conta: ${error.message}`);
}
```

### `/servicos/supabase/metas.ts`

```typescript
import { supabase } from './cliente';
import type { Meta, NovaMeta, MetaComProgresso } from '@/tipos';

/**
 * Buscar todas as metas ativas
 */
export async function obterMetas(incluirInativas = false): Promise<Meta[]> {
  let query = supabase
    .from('fp_metas')
    .select('*')
    .order('periodo_inicio', { ascending: false });

  if (!incluirInativas) {
    query = query.eq('ativo', true);
  }

  const { data, error } = await query;

  if (error) throw new Error(`Erro ao buscar metas: ${error.message}`);
  return data || [];
}

/**
 * Buscar metas com progresso calculado
 */
export async function obterMetasComProgresso(): Promise<MetaComProgresso[]> {
  const { data: metas, error } = await supabase
    .from('fp_metas')
    .select(`
      *,
      categoria:fp_categorias(nome, cor)
    `)
    .eq('ativo', true)
    .order('periodo_inicio', { ascending: false });

  if (error) throw new Error(`Erro ao buscar metas: ${error.message}`);

  const metasComProgresso: MetaComProgresso[] = [];

  for (const meta of metas || []) {
    const valorUsado = await calcularValorUsadoMeta(meta);
    const percentualUsado = (valorUsado / meta.valor_limite) * 100;
    const valorRestante = meta.valor_limite - valorUsado;

    let statusCor: MetaComProgresso['status_cor'] = 'verde';
    if (percentualUsado >= 100) statusCor = 'vermelho';
    else if (percentualUsado >= 80) statusCor = 'laranja';
    else if (percentualUsado >= 50) statusCor = 'amarelo';

    metasComProgresso.push({
      ...meta,
      valor_usado: valorUsado,
      percentual_usado: Math.round(percentualUsado),
      valor_restante: valorRestante,
      status_cor: statusCor
    });
  }

  return metasComProgresso;
}

/**
 * Calcular valor usado em uma meta
 */
async function calcularValorUsadoMeta(meta: Meta): Promise<number> {
  let query = supabase
    .from('fp_transacoes')
    .select('valor')
    .gte('data', meta.periodo_inicio)
    .lte('data', meta.periodo_fim)
    .eq('status', 'pago');

  // Se meta √© por categoria espec√≠fica
  if (meta.tipo === 'categoria' && meta.categoria_id) {
    query = query.eq('categoria_id', meta.categoria_id);
  }

  // Apenas despesas contam para as metas
  query = query.eq('tipo', 'despesa');

  const { data, error } = await query;

  if (error) throw new Error(`Erro ao calcular meta: ${error.message}`);

  return (data || []).reduce((total, transacao) => total + transacao.valor, 0);
}

/**
 * Criar nova meta
 */
export async function criarMeta(meta: NovaMeta): Promise<Meta> {
  const { data, error } = await supabase
    .from('fp_metas')
    .insert([meta])
    .select()
    .single();

  if (error) throw new Error(`Erro ao criar meta: ${error.message}`);
  return data;
}

/**
 * Atualizar meta
 */
export async function atualizarMeta(
  id: string, 
  atualizacoes: Partial<NovaMeta>
): Promise<void> {
  const { error } = await supabase
    .from('fp_metas')
    .update(atualizacoes)
    .eq('id', id);

  if (error) throw new Error(`Erro ao atualizar meta: ${error.message}`);
}

/**
 * Desativar meta
 */
export async function desativarMeta(id: string): Promise<void> {
  const { error } = await supabase
    .from('fp_metas')
    .update({ ativo: false })
    .eq('id', id);

  if (error) throw new Error(`Erro ao desativar meta: ${error.message}`);
}
```

---

## ü™ù Hooks Customizados e Context API

### `/contextos/transacoes-contexto.tsx` (Estado global compartilhado)

```typescript
/**
 * Context API para gerenciar estado global de transa√ß√µes
 * 
 * QUANDO USAR:
 * - Lista principal de transa√ß√µes na aplica√ß√£o
 * - Dados que precisam ser compartilhados entre m√∫ltiplos componentes
 * - Dashboard que mostra resumos de transa√ß√µes
 * - Qualquer componente que precisa de sincroniza√ß√£o autom√°tica
 * 
 * VANTAGENS:
 * - Estado centralizado e sincronizado
 * - Evita prop drilling
 * - Atualiza√ß√µes autom√°ticas em todos os componentes
 * 
 * COMO USAR:
 * 1. Envolver o app com <TransacoesProvider>
 * 2. Usar useTransacoesContexto() nos componentes
 */

import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { 
  obterTransacoes, 
  criarTransacao, 
  atualizarTransacao, 
  excluirTransacao 
} from '@/servicos/supabase/transacoes';
import type { 
  TransacaoComRelacoes, 
  NovaTransacao, 
  AtualizarTransacao,
  FiltrosTransacao,
  ParametrosPaginacao,
  RespostaPaginada
} from '@/tipos';

interface TransacoesContextoType {
  transacoes: TransacaoComRelacoes[];
  carregando: boolean;
  erro: string | null;
  paginacao: RespostaPaginada<TransacaoComRelacoes> | null;
  recarregar: () => Promise<void>;
  criar: (transacao: NovaTransacao) => Promise<void>;
  atualizar: (id: string, dados: AtualizarTransacao) => Promise<void>;
  excluir: (id: string) => Promise<void>;
  aplicarFiltros: (filtros: FiltrosTransacao) => void;
  aplicarPaginacao: (params: ParametrosPaginacao) => void;
}

const TransacoesContexto = createContext<TransacoesContextoType | undefined>(undefined);

export function TransacoesProvider({ children }: { children: ReactNode }) {
  const [transacoes, setTransacoes] = useState<TransacaoComRelacoes[]>([]);
  const [carregando, setCarregando] = useState(true);
  const [erro, setErro] = useState<string | null>(null);
  const [paginacao, setPaginacao] = useState<RespostaPaginada<TransacaoComRelacoes> | null>(null);
  const [filtros, setFiltros] = useState<FiltrosTransacao>({});
  const [paramsPaginacao, setParamsPaginacao] = useState<ParametrosPaginacao>({
    pagina: 1,
    limite: 20,
    ordenacao: 'data',
    direcao: 'desc'
  });

  const carregarTransacoes = async () => {
    try {
      setCarregando(true);
      setErro(null);
      
      const resposta = await obterTransacoes(filtros, paramsPaginacao);
      
      setTransacoes(resposta.dados);
      setPaginacao(resposta);
    } catch (error) {
      setErro(error instanceof Error ? error.message : 'Erro desconhecido');
    } finally {
      setCarregando(false);
    }
  };

  useEffect(() => {
    carregarTransacoes();
  }, [filtros, paramsPaginacao]);

  const criar = async (transacao: NovaTransacao) => {
    try {
      await criarTransacao(transacao);
      await carregarTransacoes();
    } catch (error) {
      throw error;
    }
  };

  const atualizar = async (id: string, dados: AtualizarTransacao) => {
    try {
      await atualizarTransacao(id, dados);
      await carregarTransacoes();
    } catch (error) {
      throw error;
    }
  };

  const excluir = async (id: string) => {
    try {
      await excluirTransacao(id);
      await carregarTransacoes();
    } catch (error) {
      throw error;
    }
  };

  const aplicarFiltros = (novosFiltros: FiltrosTransacao) => {
    setFiltros(novosFiltros);
    setParamsPaginacao(prev => ({ ...prev, pagina: 1 }));
  };

  const aplicarPaginacao = (params: ParametrosPaginacao) => {
    setParamsPaginacao(params);
  };

  return (
    <TransacoesContexto.Provider value={{
      transacoes,
      carregando,
      erro,
      paginacao,
      recarregar: carregarTransacoes,
      criar,
      atualizar,
      excluir,
      aplicarFiltros,
      aplicarPaginacao
    }}>
      {children}
    </TransacoesContexto.Provider>
  );
}

export function useTransacoesContexto() {
  const contexto = useContext(TransacoesContexto);
  if (contexto === undefined) {
    throw new Error('useTransacoesContexto deve ser usado dentro de TransacoesProvider');
  }
  return contexto;
}
```

### `/hooks/usar-transacoes.ts` (Para componentes isolados)

```typescript
/**
 * Hook simples para componentes que precisam gerenciar transa√ß√µes localmente
 * 
 * QUANDO USAR:
 * - Modais ou formul√°rios isolados
 * - Componentes que n√£o precisam compartilhar estado
 * - Casos onde o Context API seria overhead
 * 
 * QUANDO N√ÉO USAR:
 * - Lista principal de transa√ß√µes (use Context API)
 * - Dados que precisam ser compartilhados entre componentes
 * - Estado global da aplica√ß√£o
 */

import { useState, useEffect, useCallback } from 'react';
import { 
  obterTransacoes, 
  criarTransacao, 
  atualizarTransacao, 
  excluirTransacao 
} from '@/servicos/supabase/transacoes';
import type { 
  TransacaoComRelacoes, 
  NovaTransacao, 
  AtualizarTransacao,
  FiltrosTransacao,
  ParametrosPaginacao,
  RespostaPaginada
} from '@/tipos';

interface UsarTransacoesReturn {
  transacoes: TransacaoComRelacoes[];
  carregando: boolean;
  erro: string | null;
  paginacao: RespostaPaginada<TransacaoComRelacoes> | null;
  recarregar: () => Promise<void>;
  criar: (transacao: NovaTransacao) => Promise<void>;
  atualizar: (id: string, dados: AtualizarTransacao) => Promise<void>;
  excluir: (id: string) => Promise<void>;
  aplicarFiltros: (filtros: FiltrosTransacao) => void;
  aplicarPaginacao: (params: ParametrosPaginacao) => void;
}

export function usarTransacoes(): UsarTransacoesReturn {
  const [transacoes, setTransacoes] = useState<TransacaoComRelacoes[]>([]);
  const [carregando, setCarregando] = useState(true);
  const [erro, setErro] = useState<string | null>(null);
  const [paginacao, setPaginacao] = useState<RespostaPaginada<TransacaoComRelacoes> | null>(null);
  const [filtros, setFiltros] = useState<FiltrosTransacao>({});
  const [paramsPaginacao, setParamsPaginacao] = useState<ParametrosPaginacao>({
    pagina: 1,
    limite: 20,
    ordenacao: 'data',
    direcao: 'desc'
  });

  const carregarTransacoes = useCallback(async () => {
    try {
      setCarregando(true);
      setErro(null);
      
      const resposta = await obterTransacoes(filtros, paramsPaginacao);
      
      setTransacoes(resposta.dados);
      setPaginacao(resposta);
    } catch (error) {
      setErro(error instanceof Error ? error.message : 'Erro desconhecido');
    } finally {
      setCarregando(false);
    }
  }, [filtros, paramsPaginacao]);

  useEffect(() => {
    carregarTransacoes();
  }, [carregarTransacoes]);

  const criar = async (transacao: NovaTransacao) => {
    try {
      await criarTransacao(transacao);
      await carregarTransacoes();
    } catch (error) {
      throw error;
    }
  };

  const atualizar = async (id: string, dados: AtualizarTransacao) => {
    try {
      await atualizarTransacao(id, dados);
      await carregarTransacoes();
    } catch (error) {
      throw error;
    }
  };

  const excluir = async (id: string) => {
    try {
      await excluirTransacao(id);
      await carregarTransacoes();
    } catch (error) {
      throw error;
    }
  };

  const aplicarFiltros = (novosFiltros: FiltrosTransacao) => {
    setFiltros(novosFiltros);
    setParamsPaginacao(prev => ({ ...prev, pagina: 1 })); // Reset para primeira p√°gina
  };

  const aplicarPaginacao = (params: ParametrosPaginacao) => {
    setParamsPaginacao(params);
  };

  return {
    transacoes,
    carregando,
    erro,
    paginacao,
    recarregar: carregarTransacoes,
    criar,
    atualizar,
    excluir,
    aplicarFiltros,
    aplicarPaginacao
  };
}
```

### `/hooks/usar-metas.ts`

```typescript
import { useState, useEffect, useCallback } from 'react';
import { 
  obterMetasComProgresso, 
  criarMeta, 
  atualizarMeta, 
  desativarMeta 
} from '@/servicos/supabase/metas';
import type { MetaComProgresso, NovaMeta } from '@/tipos';

interface UsarMetasReturn {
  metas: MetaComProgresso[];
  carregando: boolean;
  erro: string | null;
  recarregar: () => Promise<void>;
  criar: (meta: NovaMeta) => Promise<void>;
  atualizar: (id: string, dados: Partial<NovaMeta>) => Promise<void>;
  desativar: (id: string) => Promise<void>;
}

export function usarMetas(): UsarMetasReturn {
  const [metas, setMetas] = useState<MetaComProgresso[]>([]);
  const [carregando, setCarregando] = useState(true);
  const [erro, setErro] = useState<string | null>(null);

  const carregarMetas = useCallback(async () => {
    try {
      setCarregando(true);
      setErro(null);
      
      const dados = await obterMetasComProgresso();
      setMetas(dados);
    } catch (error) {
      setErro(error instanceof Error ? error.message : 'Erro desconhecido');
    } finally {
      setCarregando(false);
    }
  }, []);

  useEffect(() => {
    carregarMetas();
  }, [carregarMetas]);

  const criar = async (meta: NovaMeta) => {
    try {
      await criarMeta(meta);
      await carregarMetas();
    } catch (error) {
      throw error;
    }
  };

  const atualizar = async (id: string, dados: Partial<NovaMeta>) => {
    try {
      await atualizarMeta(id, dados);
      await carregarMetas();
    } catch (error) {
      throw error;
    }
  };

  const desativar = async (id: string) => {
    try {
      await desativarMeta(id);
      await carregarMetas();
    } catch (error) {
      throw error;
    }
  };

  return {
    metas,
    carregando,
    erro,
    recarregar: carregarMetas,
    criar,
    atualizar,
    desativar
  };
}
```

### üìã **Guia de Decis√£o: Context API vs Hook**

```typescript
// ‚úÖ USE CONTEXT API - Lista principal de transa√ß√µes
function PaginaTransacoes() {
  const { transacoes, carregando, criar } = useTransacoesContexto();
  
  return (
    <div>
      {transacoes.map(t => <ItemTransacao key={t.id} transacao={t} />)}
    </div>
  );
}

// ‚úÖ USE CONTEXT API - Dashboard (precisa dos mesmos dados)
function Dashboard() {
  const { transacoes } = useTransacoesContexto(); // Mesmos dados, sincronizados
  const ultimas = transacoes.slice(0, 5);
  
  return <UltimasTransacoes transacoes={ultimas} />;
}

// ‚úÖ USE HOOK SIMPLES - Modal isolado
function ModalNovaTransacao() {
  const { criar } = usarTransacoes(); // Estado independente
  
  const salvar = async (dados) => {
    await criar(dados);
    // Modal fecha, n√£o precisa manter estado
  };
  
  return <FormularioTransacao onSalvar={salvar} />;
}

// ‚úÖ USE HOOK SIMPLES - Relat√≥rio espec√≠fico
function RelatorioMensal() {
  const { transacoes } = usarTransacoes(); // Dados espec√≠ficos deste relat√≥rio
  
  return <GraficoMensal dados={transacoes} />;
}
```

---

## üßÆ Utilit√°rios e Formata√ß√£o

### `/utilitarios/formatacao.ts`

```typescript
/**
 * Formatar valor em reais para moeda brasileira
 */
export function formatarMoeda(valorReais: number): string {
  return new Intl.NumberFormat('pt-BR', {
    style: 'currency',
    currency: 'BRL'
  }).format(valorReais);
}

/**
 * Validar e formatar valor monet√°rio
 */
export function validarValorMonetario(valor: number): number {
  return Number(valor.toFixed(2));
}

/**
 * Somar valores monet√°rios com precis√£o
 */
export function somarValores(...valores: number[]): number {
  const soma = valores.reduce((acc, val) => acc + val, 0);
  return Number(soma.toFixed(2));
}

/**
 * Formatar data para exibi√ß√£o brasileira
 */
export function formatarData(data: string): string {
  return new Date(data).toLocaleDateString('pt-BR');
}

/**
 * Formatar data e hora para exibi√ß√£o brasileira
 */
export function formatarDataHora(data: string): string {
  return new Date(data).toLocaleString('pt-BR');
}

/**
 * Obter data no formato ISO (YYYY-MM-DD)
 */
export function obterDataISO(data: Date = new Date()): string {
  return data.toISOString().split('T')[0];
}

/**
 * Calcular diferen√ßa em dias entre duas datas
 */
export function diferencaEmDias(dataInicio: string, dataFim: string): number {
  const inicio = new Date(dataInicio);
  const fim = new Date(dataFim);
  const diferenca = fim.getTime() - inicio.getTime();
  return Math.ceil(diferenca / (1000 * 3600 * 24));
}
```

### `/utilitarios/validacao.ts`

```typescript
/**
 * Validar se valor est√° dentro dos limites
 */
export function validarValor(valor: number): boolean {
  return valor > 0 && valor <= 99999999.99; // R$ 99.999.999,99 (DECIMAL 10,2)
}

/**
 * Validar formato de data ISO
 */
export function validarDataISO(data: string): boolean {
  const regex = /^\d{4}-\d{2}-\d{2}$/;
  if (!regex.test(data)) return false;
  
  const date = new Date(data);
  return date instanceof Date && !isNaN(date.getTime());
}

/**
 * Validar se descri√ß√£o n√£o est√° vazia
 */
export function validarDescricao(descricao: string): boolean {
  return descricao.trim().length >= 3;
}

/**
 * Validar per√≠odo de meta
 */
export function validarPeriodoMeta(inicio: string, fim: string): boolean {
  if (!validarDataISO(inicio) || !validarDataISO(fim)) return false;
  return new Date(inicio) < new Date(fim);
}

/**
 * Validar transa√ß√£o completa
 */
export function validarTransacao(transacao: any): string[] {
  const erros: string[] = [];

  if (!validarDescricao(transacao.descricao)) {
    erros.push('Descri√ß√£o deve ter pelo menos 3 caracteres');
  }

  if (!validarValor(transacao.valor)) {
    erros.push('Valor deve ser positivo e at√© R$ 99.999.999,99');
  }

  if (!validarDataISO(transacao.data)) {
    erros.push('Data deve estar no formato v√°lido');
  }

  if (!transacao.conta_id) {
    erros.push('Conta √© obrigat√≥ria');
  }

  if (transacao.tipo === 'transferencia' && !transacao.conta_destino_id) {
    erros.push('Conta destino √© obrigat√≥ria para transfer√™ncias');
  }

  if (transacao.tipo === 'transferencia' && transacao.conta_id === transacao.conta_destino_id) {
    erros.push('Conta origem e destino devem ser diferentes');
  }

  return erros;
}
```

---

## üìä Exemplos de Uso da API

### Criar Transa√ß√£o Simples

```typescript
import { usarTransacoes } from '@/hooks/usar-transacoes';
import { obterDataISO } from '@/utilitarios/formatacao';

function ExemploTransacao() {
  const { criar, carregando } = usarTransacoes();

  const criarDespesa = async () => {
    await criar({
      data: obterDataISO(),
      descricao: 'Almo√ßo no restaurante',
      valor: 25.50, // R$ 25,50 em reais
      tipo: 'despesa',
      conta_id: 'uuid-da-conta',
      categoria_id: 'uuid-da-categoria-alimentacao',
      status: 'pago',
      parcela_atual: 1,
      total_parcelas: 1,
      recorrente: false
    });
  };

  return (
    <button onClick={criarDespesa} disabled={carregando}>
      Criar Despesa
    </button>
  );
}
```

### Criar Transa√ß√£o Parcelada

```typescript
import { criarTransacaoParcelada } from '@/servicos/supabase/transacoes';

const criarCompraParcelada = async () => {
  const transacaoBase = {
    data: obterDataISO(),
    descricao: 'Geladeira',
    valor: 1200.00, // R$ 1.200,00 em reais
    tipo: 'despesa' as const,
    conta_id: 'uuid-cartao-credito',
    categoria_id: 'uuid-categoria-casa',
    status: 'pendente' as const,
    parcela_atual: 1,
    total_parcelas: 1,
    recorrente: false
  };

  // Criar 12 parcelas de R$ 100,00
  const parcelas = await criarTransacaoParcelada(transacaoBase, 12);
  console.log(`Criadas ${parcelas.length} parcelas`);
};
```

### Buscar Transa√ß√µes com Filtros

```typescript
import { usarTransacoes } from '@/hooks/usar-transacoes';

function ListaComFiltros() {
  const { transacoes, aplicarFiltros, carregando } = usarTransacoes();

  const filtrarPorCategoria = (categoriaId: string) => {
    aplicarFiltros({
      categoria_id: categoriaId,
      data_inicio: '2025-08-01',
      data_fim: '2025-08-31',
      status: 'pago'
    });
  };

  if (carregando) return <div>Carregando...</div>;

  return (
    <div>
      {transacoes.map(transacao => (
        <div key={transacao.id}>
          {transacao.descricao} - {formatarMoeda(transacao.valor)}
        </div>
      ))}
    </div>
  );
}
```

---

## üöÄ Deploy e Produ√ß√£o

### Vari√°veis de Ambiente Produ√ß√£o

```env
# .env.production
NEXT_PUBLIC_SUPABASE_URL=https://nzgifjdewdfibcopolof.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
SUPABASE_SERVICE_ROLE_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
NEXT_PUBLIC_APP_URL=https://seu-dominio.vercel.app
NODE_ENV=production
```

### Comandos de Build

```bash
# Build local
npm run build

# Deploy Vercel
vercel --prod

# Verificar tipos TypeScript
npx tsc --noEmit
```

---

## üìö Refer√™ncias Adicionais

- **Supabase Docs:** https://supabase.com/docs/reference/javascript
- **Next.js App Router:** https://nextjs.org/docs/app
- **TypeScript:** https://www.typescriptlang.org/docs
- **React Hooks:** https://react.dev/reference/react

---

**Documenta√ß√£o completa da API pronta para desenvolvimento! üöÄ**